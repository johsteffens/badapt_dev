<lion_frame_eval_set_s>
    param: <lion_frame_eval_param_s>
        verbosity: -1
    </>

    arr: <lion_frame_eval_arr_s>

    <lion_frame_eval_set_s> param: <lion_frame_eval_param_s> verbosity: -1 name: "HOLOR LITERAL" </> arr: <lion_frame_eval_arr_s>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"(y<-)     {y=1:1;};"             out:"(1:1)"       </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"(y<-)     {y=1[1::2[2;};"        out:"(1:2:2)"     </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"(y<-)     {y=2[2;};"             out:"(2:2)"       </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"(y<-)     {y=2[2[0;};"           out:"(0:0):(0:0)" </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"(y<-)     {y=((1:2):(4:5))]1;};" out:"(4:5)"       </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"(y, z <-) {y=1; z=2;};"          out:"1,2"         </> </>
    </> </>

    <lion_frame_eval_set_s> param: <lion_frame_eval_param_s> name: "HOLOR SYNTAX" verbosity: -1 </> arr: <lion_frame_eval_arr_s>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"( y   <- a,b ) { y = (a:b)]1; };"               in:"1:2, 2:3"     out:"(2:3)" </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"( y   <- a,b ) { y = a + b; };"                 in:"1:1, 2:2"     out: "3:3" </>  </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"( y,z <- a,b ) { y=a+b; z=b-a; };"              in:"1:1, 2:2"     out: "3:3, 1:1" </>  </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"( y   <- a,b ) { y = a * b; };"                 in:"1:1, 2:2"     out: "2:2" </>  </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"( y   <- a,b ) { y = a:b:2[2; };"               in:"2[1, 2:3"     out:"(1:1):(2:3):(2:2)"  </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"( y   <- a,b ) { y = (a:b):(1:1); };"           in:"1:2, 2:3"     out:"(1:2):(2:3):(1:1)"  </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"( y   <- a )   { y = (2[2[a); };"               in:"1:2:3"        out: "((1:2:3):(1:2:3)):((1:2:3):(1:2:3))"  </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"( y   <- a )   { y = a + a + 1 + #; };"         in:"1"            out:"3" </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src:"( y   <- a,b ) { y = b+a/( a~**a )^( 1/2 ); };" in:"(1:1), (1:1)" out:"(1.70711:1.70711)"  </> </>
    </> </>

    <lion_frame_eval_set_s> param: <lion_frame_eval_param_s> name: "HOLOR SYNTAX2" verbosity: -1 epsilon: 1E-3 max_dev: 1E-2 </> arr: <lion_frame_eval_arr_s>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src: "( y <- a = 2[# ) { y = a; };" in:"f2_t(1:2)"          out:"f3_t(1:2)" </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src: "( y <- a ) { y = a; };"       in:"f2_t((1:2):(3:4))"  out:"f2_t((1:2):(3:4))"  </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src: "( y <- a ) { y = exp( lgst((-(a-3)*5*a+5)+16 )+lgst(-1)); };" in: "4"  out:"2.718281828" </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src: "( y <- a ) { y = a~~; };"     in: "f2_t((1:2):(3:4))"     out:"f2_t((1:2):(3:4))"  </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src: "( y <- a ) { y = ( a~ ** a ); };"   in:  "(1:2):(3:4)"    out: "(10:14):(14:20)"   </> </>
        <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s> src: "( y <- a, b ) { y = a / ( b + a ); };" in: "1:2, f2_t(2)" out: "0.33333:0.5"       </> </>
    </> </>

    <lion_frame_eval_frame_s> param: <lion_frame_eval_param_s>
        name: "ACKERMANN" verbosity: -1
        src:
        "
            cell ( y <- )
            {
                cell ack( y <- n, m )
                {
                    y =
                      if     ( n == 0 ) then m + 1;
                      else if( m == 0 ) then ack( n - 1, 1 );
                      else                   ack( n - 1, ack( n, m - 1 ) );
                };
                y = ack( 3, 2 );
            }
        "
        out:"29"
    </> </>

    <lion_frame_eval_frame_s>
        param: <lion_frame_eval_param_s>
            name: "FIBONNACCI" verbosity: -1
            src:
            "
                cell ( y <- )
                {
                    cyclic f0 = 0;
                    cyclic f1 = 1;
                    y = f1;
                    fnext = f0 + f1;
                    f0 = f1;
                    f1 = fnext;
                }
            "
            out:"144"
        </>
        jacobian_test: false
        ap_cycles: 12
    </>

    <lion_frame_eval_frame_s>
        param: <lion_frame_eval_param_s>
            name: "ADAPT (Vector)" verbosity: -1

            src:
            "
                cell( y <- a )
                {
                    adaptive v1 = ( 0.5 : 1.0 );
                    y = a~ ** v1;
                }
            "

            in: "( 1 : 2 )"
            out: "2.5"
        </>
    </>

    <lion_frame_eval_frame_s>
        param: <lion_frame_eval_param_s>
            name: "Frame adaptive" verbosity: -1 max_dev: 1E-4
            src:
            "
                ( y <- a )
                {
                    adaptive w = (3:1) : (2:1);
                    y = w ** a;
                };
            "
            in: "1:2"
            out:"5:4"
        </>
        jacobian_test: true
    </>

    <lion_frame_eval_frame_s>
        param: <lion_frame_eval_param_s>
            name: "Frame MLP" verbosity: -1 max_dev: 1E-4
            src:
            "
                cell ( y <- a )
                {
                    cell layer( y <- hidden_nodes, a )
                    {
                        adaptive w = random( hidden_nodes [ dimof( a ) [ # );
                        adaptive b = hidden_nodes [ 0;
                        q = w ** a + b;

                        adaptive c = 0.5;

                        // switch between activation functions
                        y = c * tanh( q ) + ( 1 - c ) * relu( q );
                    };

                    y =	layer( 1 ) <: layer( 16 ) <: layer( 16 ) <: layer( 16, a );
                }
            "
            in: "32[1"
            out:"1[-0.10596"
        </>
        jacobian_test: true
    </>

    <lion_frame_eval_frame_s>
        param: <lion_frame_eval_param_s>
            name: "Frame nested" verbosity: -1 max_dev: 1E-4
            src:
            "
                cell ( y <- a )
                {
                    cell layer( y, z <- hidden_nodes, a )
                    {
                        adaptive w = random( hidden_nodes [ dimof( a ) [ # );
                        adaptive b = hidden_nodes [ 0;
                        q = w ** a + b;

                        adaptive c = 0.5;

                        // switch between activation functions
                        y = c * tanh( q ) + ( 1 - c ) * relu( q );
                        z = c * tanh( q );
                    };

                    y =	layer( 1, layer( 16, layer( 16, layer( 16, a ).y ).y ).y ).z;
                }
            "
            in: "32[1"
            out:"1[-0.10596"
        </>
        jacobian_test: true
    </>

    <lion_frame_eval_frame_s>
        param: <lion_frame_eval_param_s>
            name: "Frame cyclic" verbosity: 0 max_dev: 1E-4
            src: "( y <- a ) { cyclic r = 1; q = a + r; r = q; y = q; };"
            in: "1"
            out:"6"
        </>
        jacobian_test: false
        ap_cycles: 5
    </>

    <lion_frame_eval_frame_s>
        param: <lion_frame_eval_param_s>
            name: "Frame cyclic wrap" verbosity: -1 max_dev: 1E-4
            src: "( y <- a )
            {
                cell l1( l1_y <- l1_a, l1_r )
                {
                    l1_y = l1_a + l1_r;
                };

                cyclic r = 1;
                cell l2 = l1( r )( a );
                r = l2.l1_y;
                y = l2.l1_y;
            };"
            in: "1"
            out:"6"
        </>
        jacobian_test: false
        ap_cycles: 5
    </>

    <lion_frame_eval_frame_cyclic_s>
        param: <lion_frame_eval_param_s>
            name: "Frame cyclic" verbosity: -1 max_dev: 1E-4
            src: "( y <- a ) { cyclic r = 1; q = a * r; r = q; y = q; };"
            in: "1, 2, 3"
        </>
        jacobian_test: true
    </>

    <lion_frame_eval_frame_cyclic_s>
        param: <lion_frame_eval_param_s>
            name: "Frame cyclic adaptive" verbosity: -1 max_dev: 1E-4
            src: "( y <- a ) { cyclic r = 2 [ dimof( a ) [ 1; adaptive w = 2 [ dimof( a ) [ #; q = ( w * a ) * r; r = q; y = q; };"
            in: "1:2, 2:1, 3:0"
        </>
        jacobian_test: true
    </>

    <lion_frame_eval_frame_cyclic_s>
        param: <lion_frame_eval_param_s>
            name: "Frame LSTM" verbosity: 10 max_dev: 1E-3 epsilon: 1E-3
            src:
            "
                cell ( y <- a )
                {
                    cell layer( y <- dim_h, a )
                    {
                        cyclic c = dim_h [ f2_t( 0 );
                        cyclic h = dim_h [ f2_t( 0 );

                        ah = a :: h;

                        dim_ah = dimof( ah );

                        cell create_w( y <- rows, cols ) { y = random( rows [ cols [ f2_t( # ) ) * f2_t( 0.5 ); };

                        // adaptive holors
                        adaptive w_f = create_w( dim_h, dim_ah );
                        adaptive w_i = create_w( dim_h, dim_ah );
                        adaptive w_o = create_w( dim_h, dim_ah );
                        adaptive w_q = create_w( dim_h, dim_ah );

                        adaptive b_f = dim_h [ f2_t( 0 );
                        adaptive b_i = dim_h [ f2_t( 0 );
                        adaptive b_o = dim_h [ f2_t( 0 );
                        adaptive b_q = dim_h [ f2_t( 0 );

                        v_f = lgst( ( w_f ** ah ) + b_f );
                        v_i = lgst( ( w_i ** ah ) + b_i );
                        v_o = lgst( ( w_o ** ah ) + b_o );
                        v_q = tanh( ( w_q ** ah ) + b_q );

                        c_ = ( v_f * c ) + ( v_i * v_q );

                        y = ( v_o * tanh( c_ ) );
                        h = y;

                        c = c_;
                    };

                    cell lstm( y <- dim_out, dim_h, a )
                    {
                        adaptive w_r = random( dim_out [ dim_h [ f2_t( # ) );
                        adaptive b_r =         dim_out [ f2_t( # );
                        y = softmax( w_r ** layer( dim_h, a ) + b_r );
                    };

                    y = lstm( 2, 4, f2_t( a ) );
                };
            "
            in: "0:1, 1:0, 0:1, 0:1"
        </>
        jacobian_test: true
    </>

    </>
</>
