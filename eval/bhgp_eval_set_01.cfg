<bhgp_eval_e2e_set_s>
    sig:       <st_s> "( y => a )" </>
    verbosity: <s2_t>-1             </>
    max_dev:   <f3_t>1e-08 </>
    arr: <bhgp_eval_arr_e2e_s>

// ---------------------------------------------------------------------------------------------------------------------

<bhgp_eval_e2e_s>
    name: <st_s> "COPY"   </>
    src:  <st_s> "y = a;" </>
    in: <bmath_hf3_adl_s> <st_s> "( ( 1 2 )( 3 4 ) )" </> </>
    out:<bmath_hf3_adl_s> <st_s> "( ( 1 2 )( 3 4 ) )" </> </>
</>

// ---------------------------------------------------------------------------------------------------------------------

<bhgp_eval_e2e_s>
    name: <st_s> "SCALAR OPERATIONS" </>
    src:  <st_s> "y = exp( lgst( ( -( a - 3 ) * 5 * a + 5 ) + 16 ) + lgst( -1 ) );" </>
    in: <bmath_hf3_adl_s> <st_s> "  4" </> </>
    out:<bmath_hf3_adl_s> <st_s> "2.718281828" </> </>
</>

// ---------------------------------------------------------------------------------------------------------------------

<bhgp_eval_e2e_s>
    name: <st_s> "ACKERMANN" </>  sig: <st_s> "( y => )" </>
    src:  <st_s>
    "
        cell ack( y => n, m )
        {
            y =
              if     ( n == 0 ) then m + 1;
              else if( m == 0 ) then ack( n - 1, 1 );
              else                   ack( n - 1, ack( n, m - 1 ) );
        };
        y = ack( 3, 2 );
    "
    </>
    out:<bmath_hf3_adl_s> <st_s> "29" </> </>
</>

// ---------------------------------------------------------------------------------------------------------------------

<bhgp_eval_e2e_s>
    name: <st_s> "ADAPT (Scalar)" </>  sig:<st_s> "( y => a )" </>

    src:  <st_s>
    "
        w1 = adapt(  0.5 );
        w2 = adapt(  0.7 );
        w3 = adapt( -0.3 );
        y = tanh( lgst( w1 ) * tanh( w2 ) + lgst_leaky( w2 * w3 ) + a );
    "
    </>

    in: <bmath_hf3_adl_s> <st_s> "1" </> </>

    grad: <bhgp_eval_grad_s> epsilon:<f3_t>0.001</> out:<bmath_hf3_adl_s> <st_s> "3" </> </>  max_dev:<f3_t>1e-02</> </>

    //verbosity:<s2_t>5</>
    max_dev:<f3_t>1e-08</>
</>

// ---------------------------------------------------------------------------------------------------------------------

<bhgp_eval_e2e_s>
    name: <st_s> "ADAPT (Mat*Vec)" </>  sig:<st_s> "( y, z => a )" </>

    src:  <st_s>
    "
        verify_signature( y, z => a );

        dimmid = 4;
        v1 = adapt : rand( [dimof(a)]# );
        v2 = adapt : rand( [dimmid  ]# );
        w1 = adapt :     ( [dimmid  ][dimof(a)]# );
        w2 = adapt : rand( [dimmid  ][dimof(a)]# );
        w3 = adapt : rand( [dimof(a)][dimmid  ]# );

        // some wild operations with all adaptives
        y = ( lgst( w1 ** a ) * tanh( w3 ^* a ) + v2 + lgst_leaky( w2 + w1 ) ** ( a - v1 ) ) ^* rand( [dimmid]# );
        z = ( lgst( w1 *^ w2 *^ w3 ) ** a ) ^* rand( [dimmid]# );
    "
    </>

    in: <bmath_hf3_adl_s> <st_s> "( 1 2 3 )" </> </>

    grad: <bhgp_eval_grad_s>
        epsilon:<f3_t>0.00001</>
        out:<bmath_hf3_adl_s> <st_s> "-3" </> <st_s> "0" </> </>
        max_dev:<f3_t>1e-02</>
    </>

    //verbosity:<s2_t>5</>

    max_dev:<f3_t>1e-08</>
</>

// ---------------------------------------------------------------------------------------------------------------------

<bhgp_eval_e2e_s>
    name: <st_s> "ADAPT (Mat*Mat)" </>  sig:<st_s> "( y, z => a )" </>

    src:  <st_s>
    "
        verify_signature ( y, z => a );

        dm = 4;
        w1 = adapt : rand ( [dm][dimof(a)]# );
        w2 = adapt : rand ( [dimof(a)][dm]# );
        v1 =         rand ( [dm]# );

        y = ( ( w1 ** a ) ^* v1 ) ^* rand ( [dimof(a[0])]# );
        z = ( ( a ^* w2 ) ** v1 ) ^* rand ( [dimof(a[0])]# );
    "
    </>

    in: <bmath_hf3_adl_s> <st_s> "(( 1 2 3 )( -1 -2 -3 ))" </> </>

    grad: <bhgp_eval_grad_s>
        epsilon:<f3_t>0.00001</>
        out:<bmath_hf3_adl_s> <st_s> "1" </> <st_s> "1" </> </>
        max_dev:<f3_t>1e-02</>
    </>

    //verbosity:<s2_t>5</>

    max_dev:<f3_t>1e-08</>
</>

    </>
</>
