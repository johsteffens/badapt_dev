<haptive_eval_set_s>
    sig:       <st_s> "( y => a )" </>
    verbosity: <s2_t>-1            </>
    max_dev:   <f3_t>1e-08 </>
    arr: <haptive_eval_arr_s>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "COPY"   </>
            src:  <st_s> "y = a;" </>
            in: <bhvm_hf3_adl_s> <st_s> "( ( 1 2 )( 3 4 ) )" </> </>
            out:<bhvm_hf3_adl_s> <st_s> "( ( 1 2 )( 3 4 ) )" </> </>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "SCALAR OPERATIONS" </>
            src:  <st_s> "y = exp( lgst( ( -( a - 3 ) * 5 * a + 5 ) + 16 ) + lgst( -1 ) );" </>
            in: <bhvm_hf3_adl_s> <st_s> "  4" </> </>
            out:<bhvm_hf3_adl_s> <st_s> "2.718281828" </> </>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "HTP OPERATIONS" </>
            src:  <st_s> "y = a^t^t;" </>
            in: <bhvm_hf3_adl_s> <st_s> "( ( 1 2 )( 3 4 ) )" </> </>
            out:<bhvm_hf3_adl_s> <st_s> "( ( 1 2 )( 3 4 ) )" </> </>
            //verbosity:<s2_t>5</>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "ACKERMANN" </>  sig: <st_s> "( y => )" </>
            src:  <st_s>
            "
                cell ack( y => n, m )
                {
                    y =
                      if     ( n == 0 ) then m + 1;
                      else if( m == 0 ) then ack( n - 1, 1 );
                      else                   ack( n - 1, ack( n, m - 1 ) );
                };
                y = ack( 3, 2 );
            "
            </>
            out:<bhvm_hf3_adl_s> <st_s> "29" </> </>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "ADAPT (Scalar)" </>  sig:<st_s> "( y => a )" </>

            src:  <st_s>
            "
                adaptive w1 =  0.5;
                adaptive w2 =  0.7;
                adaptive w3 = -0.3;
                y = tanh( lgst( w1 ) * tanh( w2 ) + lgst_leaky( w2 * w3 ) + a );
            "
            </>

            in: <bhvm_hf3_adl_s> <st_s> "1" </> </>

            grad: <haptive_eval_grad_s> epsilon:<f3_t>0.001</> out:<bhvm_hf3_adl_s> <st_s> "3" </> </>  max_dev:<f3_t>1e-02</> </>

            // verbosity:<s2_t>5</>
            max_dev:<f3_t>1e-08</>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "ADAPT (Vector)" </>  sig:<st_s> "( y => a )" </>

            src:  <st_s>
            "
                adaptive v1 = ( 0.5 1.0 );
                y = a^t ** v1;
            "
            </>

            in: <bhvm_hf3_adl_s> <st_s> "( 1 2 )" </> </>

            grad: <haptive_eval_grad_s> epsilon:<f3_t>0.001</> out:<bhvm_hf3_adl_s> <st_s> "1" </> </>  max_dev:<f3_t>1e-02</> </>

            //verbosity:<s2_t>2</>
            max_dev:<f3_t>1e-08</>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "ADAPT (Vector,Mat)" </>  sig:<st_s> "( y => a )" </>

            src:  <st_s>
            "
                adaptive w1 = ( ( 1 2 ) ( -1 0 ) );
                v2 = ( 1 2 );
                y = ( ( ( w1 ** a )^t ) ** v2 )^t ** v2;
            "
            </>

            in: <bhvm_hf3_adl_s> <st_s> "( ( 1 2 ) ( 1 2 ) )" </> </>

            grad: <haptive_eval_grad_s> epsilon:<f3_t>0.001</> out:<bhvm_hf3_adl_s> <st_s> "1" </> </>  max_dev:<f3_t>1e-02</> </>

            //verbosity:<s2_t>2</>
            max_dev:<f3_t>1e-08</>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "ADAPT (Out Channels)" </>  sig:<st_s> "( y, z => a )" </>

            src:  <st_s>
            "
                verify_signature ( y, z => a );
                adaptive w1 = random ( [dimof(a)][dimof(a)]# );

                // 'adaptive' can be used as attribute or operator
                // If used as attribute, the variable name is remembered and can be used to identify the adaptive holor in the virtual machine.
                v1 = adaptive( random ( [dimof(a)]# ) );
                y = ( ( w1 + w1^t ) ** a )^t ** v1;
                z = ( a^t ** w1^t ) ** v1;
            "
            </>

            in: <bhvm_hf3_adl_s> <st_s> "( 1 2 )" </> </>

            grad: <haptive_eval_grad_s>
                epsilon:<f3_t>0.00001</>
                out:<bhvm_hf3_adl_s> <st_s> "1" </> <st_s> "1" </> </>
                max_dev:<f3_t>1e-02</>
            </>

            //verbosity:<s2_t>5</>

            max_dev:<f3_t>1e-08</>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "ADAPT (Mat*Mat)" </>  sig:<st_s> "( y, z => a )" </>

            src:  <st_s>
            "
                verify_signature ( y, z => a );

                dm = 4;
                adaptive w1 = random ( [dm][dimof(a)]# );
                adaptive w2 = random ( [dimof(a)][dm]# );
                adaptive v1 = random ( [dm]# );
                y = ( ( w1  ** a )^t  ** v1 )^t ** random ( [dimof(a[0])]# );
                z = ( ( a^t ** w1^t ) ** v1 )^t ** random ( [dimof(a[0])]# );
            "
            </>

            in: <bhvm_hf3_adl_s> <st_s> "(( 1 2 3 )( -1 -2 -3 ))" </> </>

            grad: <haptive_eval_grad_s>
                epsilon:<f3_t>0.00001</>
                out:<bhvm_hf3_adl_s> <st_s> "1" </> <st_s> "1" </> </>
                max_dev:<f3_t>1e-02</>
            </>

            //verbosity:<s2_t>5</>

            max_dev:<f3_t>1e-08</>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "ADAPT (crazy)" </>  sig:<st_s> "( y, z => a )" </>

            src:  <st_s>
            "
                verify_signature( y, z => a );

                dimmid = 4;
                adaptive v1 = random( [dimof(a)]# );
                adaptive v2 = random( [dimmid  ]# );
                adaptive w1 = random( [dimmid  ][dimof(a)]# );
                adaptive w2 = random( [dimmid  ][dimof(a)]# );
                adaptive w3 =       ( [dimof(a)][dimmid  ]# ); // auto-randomization

                // some wild crazy operations with all adaptives
                y = ( ( lgst( w1 ** a ) * tanh( w3^t ** a ) + v2 + lgst_leaky( w2 + w1 ) ** ( a - v1 ) ) )^t ** random( [dimmid]# );
                z = ( ( lgst( w1 ** w2^t ** w3^t ) ** a ) )^t ** random( [dimmid]# );
            "
            </>

            in: <bhvm_hf3_adl_s> <st_s> "( 1 2 3 )" </> </>

            grad: <haptive_eval_grad_s>
                epsilon:<f3_t>0.00001</>
                out:<bhvm_hf3_adl_s> <st_s> "-2" </> <st_s> "-2" </> </>
                max_dev:<f3_t>1e-02</>
            </>

            //verbosity:<s2_t>5</>

            max_dev:<f3_t>1e-08</>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        <haptive_eval_e2e_s>
            name: <st_s> "Forward Recurrent" </>  sig:<st_s> "( y => a )" </>

            src:  <st_s>
            "
                verify_signature( y => a );
                cell plus( y => a, b ) { y = a + b; };
                recurrent q = -10;
                q = plus( q, a );
                y = q;
            "
            </>

            infer_cycles: <sz_t> 20 </>
            in: <bhvm_hf3_adl_s> <st_s> "2" </> </>
            //verbosity:<s2_t>10</>
            max_dev:<f3_t>1e-08</>
        </>

/// --------------------------------------------------------------------------------------------------------------------

        /** This test creates a network with branch- and fuse-points in order to test
         *  correct fusion behavor in forward mapping and gradient computation.
         */
        <haptive_eval_e2e_s>
            name: <st_s> "Branch-Fuse" </>  sig:<st_s> "( y => a )" </>

            src:  <st_s>
            "
                verify_signature( y => a );
                adaptive w = 1;
                a1 = a * w;
                adaptive w1 = 10;
                b1 = a1 * w1;
                adaptive w2 = 20;
                b2 = a1 * w2;
                y  = b1 + b2;
            "
            </>

            infer_cycles: <sz_t> 20 </>
            in: <bhvm_hf3_adl_s> <st_s> "2" </> </>
            out:<bhvm_hf3_adl_s> <st_s> "60" </> </>
            grad: <haptive_eval_grad_s> epsilon:<f3_t>0.001</> out:<bhvm_hf3_adl_s> <st_s> "50" </> </>  max_dev:<f3_t>1e-02</> </>

            // verbosity:<s2_t>10</>
            max_dev:<f3_t>1e-08</>
        </>

/// --------------------------------------------------------------------------------------------------------------------

    </>
</>
