<lion_net_eval_set_s>
    param: <lion_net_eval_param_s>
        verbosity: -1
    </>

    arr: <lion_net_eval_arr_s>

    <lion_net_eval_set_s> param: <lion_net_eval_param_s> verbosity: -1 name: "HOLOR LITERAL" </> arr: <lion_net_eval_arr_s>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"(y<-)     {y=1:1;};"             out:"(1:1)"       </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"(y<-)     {y=1[1::2[2;};"        out:"(1:2:2)"     </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"(y<-)     {y=2[2;};"             out:"(2:2)"       </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"(y<-)     {y=2[2[0;};"           out:"(0:0):(0:0)" </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"(y<-)     {y=((1:2):(4:5))]1;};" out:"(4:5)"       </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"(y, z <-) {y=1; z=2;};"          out:"1,2"         </> </>
    </> </>

    <lion_net_eval_set_s> param: <lion_net_eval_param_s> name: "HOLOR SYNTAX" verbosity: -1 </> arr: <lion_net_eval_arr_s>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"( y   <- a,b ) { y = (a:b)]1; };"               in:"1:2, 2:3"     out:"(2:3)" </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"( y   <- a,b ) { y = a + b; };"                 in:"1:1, 2:2"     out: "3:3" </>  </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"( y,z <- a,b ) { y=a+b; z=b-a; };"              in:"1:1, 2:2"     out: "3:3, 1:1" </>  </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"( y   <- a,b ) { y = a * b; };"                 in:"1:1, 2:2"     out: "2:2" </>  </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"( y   <- a,b ) { y = a:b:2[2; };"               in:"2[1, 2:3"     out:"(1:1):(2:3):(2:2)"  </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"( y   <- a,b ) { y = (a:b):(1:1); };"           in:"1:2, 2:3"     out:"(1:2):(2:3):(1:1)"  </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"( y   <- a )   { y = (2[2[a); };"               in:"1:2:3"        out: "((1:2:3):(1:2:3)):((1:2:3):(1:2:3))"  </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"( y   <- a )   { y = a + a + 1 + #; };"         in:"1"            out:"3" </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src:"( y   <- a,b ) { y = b+a/( a~**a )^( 1/2 ); };" in:"(1:1), (1:1)" out:"(1.70711:1.70711)"  </> </>
    </> </>

    <lion_net_eval_set_s> param: <lion_net_eval_param_s> name: "HOLOR SYNTAX2" verbosity: -1 epsilon: 1E-3 max_dev: 1E-2 </> arr: <lion_net_eval_arr_s>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src: "( y <- a = 2[# ) { y = a; };" in:"f2_t(1:2)"          out:"f3_t(1:2)" </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src: "( y <- a ) { y = a; };"       in:"f2_t((1:2):(3:4))"  out:"f2_t((1:2):(3:4))"  </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src: "( y <- a ) { y = exp( lgst((-(a-3)*5*a+5)+16 )+lgst(-1)); };" in: "4"  out:"2.718281828" </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src: "( y <- a ) { y = a~~; };"     in: "f2_t((1:2):(3:4))"     out:"f2_t((1:2):(3:4))"  </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src: "( y <- a ) { y = ( a~ ** a ); };"   in:  "(1:2):(3:4)"    out: "(10:14):(14:20)"   </> </>
        <lion_net_eval_frame_s> param: <lion_net_eval_param_s> src: "( y <- a, b ) { y = a / ( b + a ); };" in: "1:2, f2_t(2)" out: "0.33333:0.5"       </> </>
    </> </>

    <lion_net_eval_frame_s> param: <lion_net_eval_param_s>
        name: "ACKERMANN" verbosity: -1
        src:
        "
            cell ( y <- )
            {
                cell ack( y <- n, m )
                {
                    y =
                      if     ( n == 0 ) then m + 1;
                      else if( m == 0 ) then ack( n - 1, 1 );
                      else                   ack( n - 1, ack( n, m - 1 ) );
                };
                y = ack( 3, 2 );
            }
        "
        out:"29"
    </> </>

    <lion_net_eval_frame_s>
        param: <lion_net_eval_param_s>
            name: "FIBONNACCI" verbosity: -1
            src:
            "
                cell ( y <- )
                {
                    cyclic f0 = 0;
                    cyclic f1 = 1;
                    y = f1;
                    fnext = f0 + f1;
                    f0 = f1;
                    f1 = fnext;
                }
            "
            out:"144"
        </>
        jacobian_test: false
        ap_cycles: 12
    </>

    <lion_net_eval_frame_s>
        param: <lion_net_eval_param_s>
            name: "ADAPT (Vector)" verbosity: -1

            src:
            "
                cell( y <- a )
                {
                    adaptive v1 = ( 0.5 : 1.0 );
                    y = a~ ** v1;
                }
            "

            in: "( 1 : 2 )"
            out: "2.5"
        </>
    </>

    <lion_net_eval_frame_s>
        param: <lion_net_eval_param_s>
            name: "Frame adaptive" verbosity: -1 max_dev: 1E-4
            src:
            "
                ( y <- a )
                {
                    adaptive w = (3:1) : (2:1);
                    y = w ** a;
                };
            "
            in: "1:2"
            out:"5:4"
        </>
        jacobian_test: true
    </>

    <lion_net_eval_frame_s>
        param: <lion_net_eval_param_s>
            name: "Frame MLP" verbosity: -1 max_dev: 1E-4
            src:
            "
                cell ( y <- a )
                {
                    cell layer( y <- hidden_nodes, a )
                    {
                        adaptive w = random( hidden_nodes [ dimof( a ) [ # );
                        adaptive b = hidden_nodes [ 0;
                        q = w ** a + b;

                        adaptive c = 0.5;

                        // switch between activation functions
                        y = c * tanh( q ) + ( 1 - c ) * relu( q );
                    };

                    y =	layer( 1 ) <: layer( 16 ) <: layer( 16 ) <: layer( 16, a );
                }
            "
            in: "32[1"
            out:"1[-0.10596"
        </>
        jacobian_test: true
    </>

    <lion_net_eval_frame_s>
        param: <lion_net_eval_param_s>
            name: "Frame nested" verbosity: -1 max_dev: 1E-4
            src:
            "
                cell ( y <- a )
                {
                    cell layer( y, z <- hidden_nodes, a )
                    {
                        adaptive w = random( hidden_nodes [ dimof( a ) [ # );
                        adaptive b = hidden_nodes [ 0;
                        q = w ** a + b;

                        adaptive c = 0.5;

                        // switch between activation functions
                        y = c * tanh( q ) + ( 1 - c ) * relu( q );
                        z = c * tanh( q );
                    };

                    y =	layer( 1, layer( 16, layer( 16, layer( 16, a ).y ).y ).y ).z;
                }
            "
            in: "32[1"
            out:"1[-0.10596"
        </>
        jacobian_test: true
    </>

    <lion_net_eval_frame_s>
        param: <lion_net_eval_param_s>
            name: "Frame cyclic" verbosity: 0 max_dev: 1E-4
            src: "( y <- a ) { cyclic r = 1; q = a + r; r = q; y = q; };"
            in: "1"
            out:"6"
        </>
        jacobian_test: false
        ap_cycles: 5
    </>

    <lion_net_eval_frame_s>
        param: <lion_net_eval_param_s>
            name: "Frame cyclic wrap" verbosity: -1 max_dev: 1E-4
            src: "( y <- a )
            {
                cell l1( l1_y <- l1_a, l1_r )
                {
                    l1_y = l1_a + l1_r;
                };

                cyclic r = 1;
                cell l2 = l1( r )( a );
                r = l2.l1_y;
                y = l2.l1_y;
            };"
            in: "1"
            out:"6"
        </>
        jacobian_test: false
        ap_cycles: 5
    </>

    <lion_net_eval_frame_cyclic_s>
        param: <lion_net_eval_param_s>
            name: "Frame cyclic" verbosity: -1 max_dev: 1E-4
            src: "( y <- a ) { cyclic r = 1; q = a * r; r = q; y = q; };"
            in: "1, 2, 3"
        </>
        jacobian_test: true
    </>

    <lion_net_eval_frame_cyclic_s>
        param: <lion_net_eval_param_s>
            name: "Frame cyclic adaptive" verbosity: -1 max_dev: 1E-4
            src: "( y <- a ) { cyclic r = 2 [ dimof( a ) [ 1; adaptive w = 2 [ dimof( a ) [ #; q = ( w * a ) * r; r = q; y = q; };"
            in: "1:2, 2:1, 3:0"
        </>
        jacobian_test: true
    </>

    <lion_net_eval_frame_cyclic_s>
        param: <lion_net_eval_param_s>
            name: "Frame LSTM" verbosity: 10 max_dev: 1E-4
            src:
            "
                cell ( y <- a )
                {
                    cell layer( y <- dim_h, a )
                    {

                        cyclic c = dim_h [ 0;
                        cyclic h = dim_h [ 0;

                        dim_a = dimof( a );

                        // adaptive holors
                        adaptive w_fx = random( dim_h [ dim_a [ # );
                        adaptive w_fh = random( dim_h [ dim_h [ # );
                        adaptive w_ix = random( dim_h [ dim_a [ # );
                        adaptive w_ih = random( dim_h [ dim_h [ # );
                        adaptive w_ox = random( dim_h [ dim_a [ # );
                        adaptive w_oh = random( dim_h [ dim_h [ # );
                        adaptive w_qx = random( dim_h [ dim_a [ # );
                        adaptive w_qh = random( dim_h [ dim_h [ # );

                        adaptive b_f = dim_h [ 0;
                        adaptive b_i = dim_h [ 0;
                        adaptive b_o = dim_h [ 0;
                        adaptive b_q = dim_h [ 0;

                        v_f = lgst( ( w_fx ** a ) + ( w_fh ** h ) + b_f );
                        v_i = lgst( ( w_ix ** a ) + ( w_ih ** h ) + b_i );
                        v_o = lgst( ( w_ox ** a ) + ( w_oh ** h ) + b_o );
                        v_q = tanh( ( w_qx ** a ) + ( w_qh ** h ) + b_q );

                        c_ = ( v_f * c ) + ( v_i * v_q );

                        y = ( v_o * tanh( c_ ) );
                        h = y;

                        c = c_;
                    };

                    cell lstm( y <- dim_h, a )
                    {
                        adaptive w_r = random( dim_h [ dim_h [ # );
                        adaptive b_r = dim_h [ #;
                        y = tanh( w_r ** layer( dim_h, a ) + b_r );
                    };

                    y = lstm( 2, a );
                };
            "
            in: "1:1, 1:2, 2:1, 3:2"
        </>
        jacobian_test: true
    </>

    </>
</>
